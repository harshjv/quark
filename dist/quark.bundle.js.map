{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///quark.bundle.js","webpack:///webpack/bootstrap bd1464aab80b4bf2f3ee?be7f","webpack:///./src/lib.js","webpack:///external \"path\"","webpack:///./~/array-filter/index.js","webpack:///./~/array-map/index.js","webpack:///./~/array-reduce/index.js","webpack:///./src/stream.js","webpack:///./~/jsonify/index.js","webpack:///./~/jsonify/lib/parse.js","webpack:///./~/jsonify/lib/stringify.js","webpack:///./~/shell-quote/index.js","webpack:///./~/xtend/immutable.js","webpack:///external \"child_process\""],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE_69__","__WEBPACK_EXTERNAL_MODULE_254__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","0","_interopRequireDefault","obj","__esModule","default","_stream","_stream2","previousTime","coerce","val","Error","stack","message","log","namespace","_len","arguments","length","args","Array","_key","currentTime","Date","diff","map","arg","JSON","stringify","time","tag","data","69","113","arr","fn","filter","ret","hasOwn","push","Object","prototype","hasOwnProperty","114","xs","f","res","x","115","acc","hasAcc","reduce","121","_defineProperty","key","value","defineProperty","enumerable","configurable","writable","_path","_path2","_xtend","_xtend2","_child_process","_shellQuote","PATH_SEP","process","platform","PATH_KEY","env","PATH","Path","ESCAPE_CHAR","ELECTRON_LIB","join","__dirname","commandToString","cmd","pattern","op","handleQuotes","s","test","replace","String","NPMBinPath","cwd","result","parent","concat","formatAndSpawn","command","opts","options","file","comspec","windowsVerbatimArguments","shell","spawn","parsed","parse","","escape","override","resolve","child","out","stdin","write","bind","setEncoding","stdout","pipe","on","console","173","174","at","ch","text","escapee","\"","\\","/","b","n","r","t","error","name","next","charAt","number","string","isFinite","hex","uffff","parseInt","fromCharCode","white","word","array","object","source","reviver","walk","holder","k","v","undefined","175","quote","escapable","lastIndex","meta","charCodeAt","toString","slice","str","partial","mind","gap","toJSON","rep","indent","apply","\b","\t","\n","\f","\r","replacer","space","246","getVar","_","pre","TOKEN","json","chunker","RegExp","CONTROL","BAREWORD","SINGLE_QUOTE","DOUBLE_QUOTE","match","Boolean","commented","j","parseEnvVar","varend","varname","substr","indexOf","index","SQ","DQ","DS","BS","esc","isGlob","len","comment","prev","META","Math","pow","random","mapped","split","253","extend","target","254"],"mappings":"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","file":"quark.bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"path\"), require(\"child_process\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"path\", \"child_process\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"path\"), require(\"child_process\")) : factory(root[\"path\"], root[\"child_process\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_69__, __WEBPACK_EXTERNAL_MODULE_254__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"path\"), require(\"child_process\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"path\", \"child_process\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"path\"), require(\"child_process\")) : factory(root[\"path\"], root[\"child_process\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_69__, __WEBPACK_EXTERNAL_MODULE_254__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _stream = __webpack_require__(121);\n\t\n\tvar _stream2 = _interopRequireDefault(_stream);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar previousTime = void 0;\n\t\n\tvar coerce = function coerce(val) {\n\t  return val instanceof Error ? val.stack || val.message : val;\n\t};\n\tvar log = (0, _stream2.default)();\n\t\n\tmodule.exports = function (namespace) {\n\t  return function () {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    var currentTime = new Date();\n\t    var diff = currentTime - (previousTime || currentTime);\n\t    previousTime = currentTime;\n\t\n\t    args = args.map(function (arg) {\n\t      return coerce(arg);\n\t    });\n\t\n\t    log(JSON.stringify({\n\t      diff: diff,\n\t      time: currentTime,\n\t      tag: namespace,\n\t      data: args\n\t    }));\n\t  };\n\t};\n\n/***/ },\n\n/***/ 69:\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"path\");\n\n/***/ },\n\n/***/ 113:\n/***/ function(module, exports) {\n\n\t/**\n\t * Array#filter.\n\t *\n\t * @param {Array} arr\n\t * @param {Function} fn\n\t * @return {Array}\n\t */\n\t\n\tmodule.exports = function (arr, fn) {\n\t  if (arr.filter) return arr.filter(fn);\n\t  var ret = [];\n\t  for (var i = 0; i < arr.length; i++) {\n\t    if (!hasOwn.call(arr, i)) continue;\n\t    if (fn(arr[i], i, arr)) ret.push(arr[i]);\n\t  }\n\t  return ret;\n\t};\n\t\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\n\n/***/ },\n\n/***/ 114:\n/***/ function(module, exports) {\n\n\tmodule.exports = function (xs, f) {\n\t    if (xs.map) return xs.map(f);\n\t    var res = [];\n\t    for (var i = 0; i < xs.length; i++) {\n\t        var x = xs[i];\n\t        if (hasOwn.call(xs, i)) res.push(f(x, i, xs));\n\t    }\n\t    return res;\n\t};\n\t\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\n\n/***/ },\n\n/***/ 115:\n/***/ function(module, exports) {\n\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\t\n\tmodule.exports = function (xs, f, acc) {\n\t    var hasAcc = arguments.length >= 3;\n\t    if (hasAcc && xs.reduce) return xs.reduce(f, acc);\n\t    if (xs.reduce) return xs.reduce(f);\n\t    \n\t    for (var i = 0; i < xs.length; i++) {\n\t        if (!hasOwn.call(xs, i)) continue;\n\t        if (!hasAcc) {\n\t            acc = xs[i];\n\t            hasAcc = true;\n\t            continue;\n\t        }\n\t        acc = f(acc, xs[i], i);\n\t    }\n\t    return acc;\n\t};\n\n\n/***/ },\n\n/***/ 121:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _path = __webpack_require__(69);\n\t\n\tvar _path2 = _interopRequireDefault(_path);\n\t\n\tvar _xtend = __webpack_require__(253);\n\t\n\tvar _xtend2 = _interopRequireDefault(_xtend);\n\t\n\tvar _child_process = __webpack_require__(254);\n\t\n\tvar _shellQuote = __webpack_require__(246);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tvar PATH_SEP = process.platform === 'win32' ? ';' : ':';\n\tvar PATH_KEY = process.platform === 'win32' && !(process.env.PATH && !process.env.Path) ? 'Path' : 'PATH';\n\tvar ESCAPE_CHAR = process.platform === 'win32' ? '^' : '\\\\';\n\tvar ELECTRON_LIB = 'electron ' + _path2.default.join(__dirname, 'electron.bundle.js');\n\t\n\tvar commandToString = function commandToString(cmd) {\n\t  return cmd.pattern || cmd.op || handleQuotes(cmd);\n\t};\n\t\n\tvar handleQuotes = function handleQuotes(s) {\n\t  if (/[\"'\\s]/.test(s)) return '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n\t  if (/[\"\\s]/.test(s) && !/'/.test(s)) return \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n\t  return String(s).replace(/([\\\\$`()!#&*|])/g, '\\\\$1');\n\t};\n\t\n\tvar NPMBinPath = function NPMBinPath(cwd, PATH) {\n\t  var result = [];\n\t  var parent = void 0;\n\t\n\t  while (true) {\n\t    parent = _path2.default.join(cwd, '..');\n\t    result.push(_path2.default.join(cwd, 'node_modules/.bin'));\n\t    if (parent === cwd) return result.concat(PATH).join(PATH_SEP);\n\t    cwd = parent;\n\t  }\n\t};\n\t\n\tvar formatAndSpawn = function formatAndSpawn(command, opts) {\n\t  var options = (0, _xtend2.default)({}, opts);\n\t  var file = void 0;\n\t  var args = void 0;\n\t\n\t  if (process.platform === 'win32') {\n\t    file = process.env.comspec || 'cmd.exe';\n\t    args = ['/s', '/c', '\"' + command + '\"'];\n\t    options.windowsVerbatimArguments = true;\n\t  } else {\n\t    file = '/bin/sh';\n\t    args = ['-c', command];\n\t    options.windowsVerbatimArguments = false;\n\t  }\n\t\n\t  if (options && options.shell) {\n\t    file = options.shell;\n\t    delete options.shell;\n\t  }\n\t\n\t  return (0, _child_process.spawn)(file, args, options);\n\t};\n\t\n\tmodule.exports = function () {\n\t  var cwd = process.cwd();\n\t  var env = process.env;\n\t  var parsed = (0, _shellQuote.parse)(ELECTRON_LIB, (0, _xtend2.default)({ '': '$' }), { escape: ESCAPE_CHAR }).map(commandToString).join(' ');\n\t\n\t  var override = _defineProperty({}, PATH_KEY, NPMBinPath(_path2.default.resolve(cwd, '.'), env[PATH_KEY] || process.env[PATH_KEY]));\n\t\n\t  var child = formatAndSpawn(parsed, { env: (0, _xtend2.default)(env, override) });\n\t  var out = child.stdin.write.bind(child.stdin);\n\t\n\t  child.stdin.setEncoding('utf-8');\n\t  child.stdout.pipe(process.stdout);\n\t\n\t  child.on('exit', function () {\n\t    out = console.log.bind(console);\n\t  });\n\t\n\t  return function (log) {\n\t    return out(log);\n\t  };\n\t};\n\n/***/ },\n\n/***/ 173:\n/***/ function(module, exports, __webpack_require__) {\n\n\texports.parse = __webpack_require__(174);\n\texports.stringify = __webpack_require__(175);\n\n\n/***/ },\n\n/***/ 174:\n/***/ function(module, exports) {\n\n\tvar at, // The index of the current character\n\t    ch, // The current character\n\t    escapee = {\n\t        '\"':  '\"',\n\t        '\\\\': '\\\\',\n\t        '/':  '/',\n\t        b:    '\\b',\n\t        f:    '\\f',\n\t        n:    '\\n',\n\t        r:    '\\r',\n\t        t:    '\\t'\n\t    },\n\t    text,\n\t\n\t    error = function (m) {\n\t        // Call error when something is wrong.\n\t        throw {\n\t            name:    'SyntaxError',\n\t            message: m,\n\t            at:      at,\n\t            text:    text\n\t        };\n\t    },\n\t    \n\t    next = function (c) {\n\t        // If a c parameter is provided, verify that it matches the current character.\n\t        if (c && c !== ch) {\n\t            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n\t        }\n\t        \n\t        // Get the next character. When there are no more characters,\n\t        // return the empty string.\n\t        \n\t        ch = text.charAt(at);\n\t        at += 1;\n\t        return ch;\n\t    },\n\t    \n\t    number = function () {\n\t        // Parse a number value.\n\t        var number,\n\t            string = '';\n\t        \n\t        if (ch === '-') {\n\t            string = '-';\n\t            next('-');\n\t        }\n\t        while (ch >= '0' && ch <= '9') {\n\t            string += ch;\n\t            next();\n\t        }\n\t        if (ch === '.') {\n\t            string += '.';\n\t            while (next() && ch >= '0' && ch <= '9') {\n\t                string += ch;\n\t            }\n\t        }\n\t        if (ch === 'e' || ch === 'E') {\n\t            string += ch;\n\t            next();\n\t            if (ch === '-' || ch === '+') {\n\t                string += ch;\n\t                next();\n\t            }\n\t            while (ch >= '0' && ch <= '9') {\n\t                string += ch;\n\t                next();\n\t            }\n\t        }\n\t        number = +string;\n\t        if (!isFinite(number)) {\n\t            error(\"Bad number\");\n\t        } else {\n\t            return number;\n\t        }\n\t    },\n\t    \n\t    string = function () {\n\t        // Parse a string value.\n\t        var hex,\n\t            i,\n\t            string = '',\n\t            uffff;\n\t        \n\t        // When parsing for string values, we must look for \" and \\ characters.\n\t        if (ch === '\"') {\n\t            while (next()) {\n\t                if (ch === '\"') {\n\t                    next();\n\t                    return string;\n\t                } else if (ch === '\\\\') {\n\t                    next();\n\t                    if (ch === 'u') {\n\t                        uffff = 0;\n\t                        for (i = 0; i < 4; i += 1) {\n\t                            hex = parseInt(next(), 16);\n\t                            if (!isFinite(hex)) {\n\t                                break;\n\t                            }\n\t                            uffff = uffff * 16 + hex;\n\t                        }\n\t                        string += String.fromCharCode(uffff);\n\t                    } else if (typeof escapee[ch] === 'string') {\n\t                        string += escapee[ch];\n\t                    } else {\n\t                        break;\n\t                    }\n\t                } else {\n\t                    string += ch;\n\t                }\n\t            }\n\t        }\n\t        error(\"Bad string\");\n\t    },\n\t\n\t    white = function () {\n\t\n\t// Skip whitespace.\n\t\n\t        while (ch && ch <= ' ') {\n\t            next();\n\t        }\n\t    },\n\t\n\t    word = function () {\n\t\n\t// true, false, or null.\n\t\n\t        switch (ch) {\n\t        case 't':\n\t            next('t');\n\t            next('r');\n\t            next('u');\n\t            next('e');\n\t            return true;\n\t        case 'f':\n\t            next('f');\n\t            next('a');\n\t            next('l');\n\t            next('s');\n\t            next('e');\n\t            return false;\n\t        case 'n':\n\t            next('n');\n\t            next('u');\n\t            next('l');\n\t            next('l');\n\t            return null;\n\t        }\n\t        error(\"Unexpected '\" + ch + \"'\");\n\t    },\n\t\n\t    value,  // Place holder for the value function.\n\t\n\t    array = function () {\n\t\n\t// Parse an array value.\n\t\n\t        var array = [];\n\t\n\t        if (ch === '[') {\n\t            next('[');\n\t            white();\n\t            if (ch === ']') {\n\t                next(']');\n\t                return array;   // empty array\n\t            }\n\t            while (ch) {\n\t                array.push(value());\n\t                white();\n\t                if (ch === ']') {\n\t                    next(']');\n\t                    return array;\n\t                }\n\t                next(',');\n\t                white();\n\t            }\n\t        }\n\t        error(\"Bad array\");\n\t    },\n\t\n\t    object = function () {\n\t\n\t// Parse an object value.\n\t\n\t        var key,\n\t            object = {};\n\t\n\t        if (ch === '{') {\n\t            next('{');\n\t            white();\n\t            if (ch === '}') {\n\t                next('}');\n\t                return object;   // empty object\n\t            }\n\t            while (ch) {\n\t                key = string();\n\t                white();\n\t                next(':');\n\t                if (Object.hasOwnProperty.call(object, key)) {\n\t                    error('Duplicate key \"' + key + '\"');\n\t                }\n\t                object[key] = value();\n\t                white();\n\t                if (ch === '}') {\n\t                    next('}');\n\t                    return object;\n\t                }\n\t                next(',');\n\t                white();\n\t            }\n\t        }\n\t        error(\"Bad object\");\n\t    };\n\t\n\tvalue = function () {\n\t\n\t// Parse a JSON value. It could be an object, an array, a string, a number,\n\t// or a word.\n\t\n\t    white();\n\t    switch (ch) {\n\t    case '{':\n\t        return object();\n\t    case '[':\n\t        return array();\n\t    case '\"':\n\t        return string();\n\t    case '-':\n\t        return number();\n\t    default:\n\t        return ch >= '0' && ch <= '9' ? number() : word();\n\t    }\n\t};\n\t\n\t// Return the json_parse function. It will have access to all of the above\n\t// functions and variables.\n\t\n\tmodule.exports = function (source, reviver) {\n\t    var result;\n\t    \n\t    text = source;\n\t    at = 0;\n\t    ch = ' ';\n\t    result = value();\n\t    white();\n\t    if (ch) {\n\t        error(\"Syntax error\");\n\t    }\n\t\n\t    // If there is a reviver function, we recursively walk the new structure,\n\t    // passing each name/value pair to the reviver function for possible\n\t    // transformation, starting with a temporary root object that holds the result\n\t    // in an empty key. If there is not a reviver function, we simply return the\n\t    // result.\n\t\n\t    return typeof reviver === 'function' ? (function walk(holder, key) {\n\t        var k, v, value = holder[key];\n\t        if (value && typeof value === 'object') {\n\t            for (k in value) {\n\t                if (Object.prototype.hasOwnProperty.call(value, k)) {\n\t                    v = walk(value, k);\n\t                    if (v !== undefined) {\n\t                        value[k] = v;\n\t                    } else {\n\t                        delete value[k];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return reviver.call(holder, key, value);\n\t    }({'': result}, '')) : result;\n\t};\n\n\n/***/ },\n\n/***/ 175:\n/***/ function(module, exports) {\n\n\tvar cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t    gap,\n\t    indent,\n\t    meta = {    // table of character substitutions\n\t        '\\b': '\\\\b',\n\t        '\\t': '\\\\t',\n\t        '\\n': '\\\\n',\n\t        '\\f': '\\\\f',\n\t        '\\r': '\\\\r',\n\t        '\"' : '\\\\\"',\n\t        '\\\\': '\\\\\\\\'\n\t    },\n\t    rep;\n\t\n\tfunction quote(string) {\n\t    // If the string contains no control characters, no quote characters, and no\n\t    // backslash characters, then we can safely slap some quotes around it.\n\t    // Otherwise we must also replace the offending characters with safe escape\n\t    // sequences.\n\t    \n\t    escapable.lastIndex = 0;\n\t    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n\t        var c = meta[a];\n\t        return typeof c === 'string' ? c :\n\t            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n\t    }) + '\"' : '\"' + string + '\"';\n\t}\n\t\n\tfunction str(key, holder) {\n\t    // Produce a string from holder[key].\n\t    var i,          // The loop counter.\n\t        k,          // The member key.\n\t        v,          // The member value.\n\t        length,\n\t        mind = gap,\n\t        partial,\n\t        value = holder[key];\n\t    \n\t    // If the value has a toJSON method, call it to obtain a replacement value.\n\t    if (value && typeof value === 'object' &&\n\t            typeof value.toJSON === 'function') {\n\t        value = value.toJSON(key);\n\t    }\n\t    \n\t    // If we were called with a replacer function, then call the replacer to\n\t    // obtain a replacement value.\n\t    if (typeof rep === 'function') {\n\t        value = rep.call(holder, key, value);\n\t    }\n\t    \n\t    // What happens next depends on the value's type.\n\t    switch (typeof value) {\n\t        case 'string':\n\t            return quote(value);\n\t        \n\t        case 'number':\n\t            // JSON numbers must be finite. Encode non-finite numbers as null.\n\t            return isFinite(value) ? String(value) : 'null';\n\t        \n\t        case 'boolean':\n\t        case 'null':\n\t            // If the value is a boolean or null, convert it to a string. Note:\n\t            // typeof null does not produce 'null'. The case is included here in\n\t            // the remote chance that this gets fixed someday.\n\t            return String(value);\n\t            \n\t        case 'object':\n\t            if (!value) return 'null';\n\t            gap += indent;\n\t            partial = [];\n\t            \n\t            // Array.isArray\n\t            if (Object.prototype.toString.apply(value) === '[object Array]') {\n\t                length = value.length;\n\t                for (i = 0; i < length; i += 1) {\n\t                    partial[i] = str(i, value) || 'null';\n\t                }\n\t                \n\t                // Join all of the elements together, separated with commas, and\n\t                // wrap them in brackets.\n\t                v = partial.length === 0 ? '[]' : gap ?\n\t                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n\t                    '[' + partial.join(',') + ']';\n\t                gap = mind;\n\t                return v;\n\t            }\n\t            \n\t            // If the replacer is an array, use it to select the members to be\n\t            // stringified.\n\t            if (rep && typeof rep === 'object') {\n\t                length = rep.length;\n\t                for (i = 0; i < length; i += 1) {\n\t                    k = rep[i];\n\t                    if (typeof k === 'string') {\n\t                        v = str(k, value);\n\t                        if (v) {\n\t                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            else {\n\t                // Otherwise, iterate through all of the keys in the object.\n\t                for (k in value) {\n\t                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n\t                        v = str(k, value);\n\t                        if (v) {\n\t                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            \n\t        // Join all of the member texts together, separated with commas,\n\t        // and wrap them in braces.\n\t\n\t        v = partial.length === 0 ? '{}' : gap ?\n\t            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n\t            '{' + partial.join(',') + '}';\n\t        gap = mind;\n\t        return v;\n\t    }\n\t}\n\t\n\tmodule.exports = function (value, replacer, space) {\n\t    var i;\n\t    gap = '';\n\t    indent = '';\n\t    \n\t    // If the space parameter is a number, make an indent string containing that\n\t    // many spaces.\n\t    if (typeof space === 'number') {\n\t        for (i = 0; i < space; i += 1) {\n\t            indent += ' ';\n\t        }\n\t    }\n\t    // If the space parameter is a string, it will be used as the indent string.\n\t    else if (typeof space === 'string') {\n\t        indent = space;\n\t    }\n\t\n\t    // If there is a replacer, it must be a function or an array.\n\t    // Otherwise, throw an error.\n\t    rep = replacer;\n\t    if (replacer && typeof replacer !== 'function'\n\t    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n\t        throw new Error('JSON.stringify');\n\t    }\n\t    \n\t    // Make a fake root object containing our value under the key of ''.\n\t    // Return the result of stringifying the value.\n\t    return str('', {'': value});\n\t};\n\n\n/***/ },\n\n/***/ 246:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar json = typeof JSON !== undefined ? JSON : __webpack_require__(173);\n\tvar map = __webpack_require__(114);\n\tvar filter = __webpack_require__(113);\n\tvar reduce = __webpack_require__(115);\n\t\n\texports.quote = function (xs) {\n\t    return map(xs, function (s) {\n\t        if (s && typeof s === 'object') {\n\t            return s.op.replace(/(.)/g, '\\\\$1');\n\t        }\n\t        else if (/[\"\\s]/.test(s) && !/'/.test(s)) {\n\t            return \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n\t        }\n\t        else if (/[\"'\\s]/.test(s)) {\n\t            return '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n\t        }\n\t        else {\n\t            return String(s).replace(/([#!\"$&'()*,:;<=>?@\\[\\\\\\]^`{|}])/g, '\\\\$1'); \n\t        }\n\t    }).join(' ');\n\t};\n\t\n\tvar CONTROL = '(?:' + [\n\t    '\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '[&;()|<>]'\n\t].join('|') + ')';\n\tvar META = '|&;()<> \\\\t';\n\tvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\n\tvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\n\tvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\n\t\n\tvar TOKEN = '';\n\tfor (var i = 0; i < 4; i++) {\n\t    TOKEN += (Math.pow(16,8)*Math.random()).toString(16);\n\t}\n\t\n\texports.parse = function (s, env, opts) {\n\t    var mapped = parse(s, env, opts);\n\t    if (typeof env !== 'function') return mapped;\n\t    return reduce(mapped, function (acc, s) {\n\t        if (typeof s === 'object') return acc.concat(s);\n\t        var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n\t        if (xs.length === 1) return acc.concat(xs[0]);\n\t        return acc.concat(map(filter(xs, Boolean), function (x) {\n\t            if (RegExp('^' + TOKEN).test(x)) {\n\t                return json.parse(x.split(TOKEN)[1]);\n\t            }\n\t            else return x;\n\t        }));\n\t    }, []);\n\t};\n\t\n\tfunction parse (s, env, opts) {\n\t    var chunker = new RegExp([\n\t        '(' + CONTROL + ')', // control chars\n\t        '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\n\t    ].join('|'), 'g');\n\t    var match = filter(s.match(chunker), Boolean);\n\t    var commented = false;\n\t\n\t    if (!match) return [];\n\t    if (!env) env = {};\n\t    if (!opts) opts = {};\n\t    return map(match, function (s, j) {\n\t        if (commented) {\n\t            return;\n\t        }\n\t        if (RegExp('^' + CONTROL + '$').test(s)) {\n\t            return { op: s };\n\t        }\n\t\n\t        // Hand-written scanner/parser for Bash quoting rules:\n\t        //\n\t        //  1. inside single quotes, all characters are printed literally.\n\t        //  2. inside double quotes, all characters are printed literally\n\t        //     except variables prefixed by '$' and backslashes followed by\n\t        //     either a double quote or another backslash.\n\t        //  3. outside of any quotes, backslashes are treated as escape\n\t        //     characters and not printed (unless they are themselves escaped)\n\t        //  4. quote context can switch mid-token if there is no whitespace\n\t        //     between the two quote contexts (e.g. all'one'\"token\" parses as\n\t        //     \"allonetoken\")\n\t        var SQ = \"'\";\n\t        var DQ = '\"';\n\t        var DS = '$';\n\t        var BS = opts.escape || '\\\\';\n\t        var quote = false;\n\t        var esc = false;\n\t        var out = '';\n\t        var isGlob = false;\n\t\n\t        for (var i = 0, len = s.length; i < len; i++) {\n\t            var c = s.charAt(i);\n\t            isGlob = isGlob || (!quote && (c === '*' || c === '?'));\n\t            if (esc) {\n\t                out += c;\n\t                esc = false;\n\t            }\n\t            else if (quote) {\n\t                if (c === quote) {\n\t                    quote = false;\n\t                }\n\t                else if (quote == SQ) {\n\t                    out += c;\n\t                }\n\t                else { // Double quote\n\t                    if (c === BS) {\n\t                        i += 1;\n\t                        c = s.charAt(i);\n\t                        if (c === DQ || c === BS || c === DS) {\n\t                            out += c;\n\t                        } else {\n\t                            out += BS + c;\n\t                        }\n\t                    }\n\t                    else if (c === DS) {\n\t                        out += parseEnvVar();\n\t                    }\n\t                    else {\n\t                        out += c;\n\t                    }\n\t                }\n\t            }\n\t            else if (c === DQ || c === SQ) {\n\t                quote = c;\n\t            }\n\t            else if (RegExp('^' + CONTROL + '$').test(c)) {\n\t                return { op: s };\n\t            }\n\t            else if (RegExp('^#$').test(c)) {\n\t                commented = true;\n\t                if (out.length){\n\t                    return [out, { comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n\t                }\n\t                return [{ comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n\t            }\n\t            else if (c === BS) {\n\t                esc = true;\n\t            }\n\t            else if (c === DS) {\n\t                out += parseEnvVar();\n\t            }\n\t            else out += c;\n\t        }\n\t\n\t        if (isGlob) return {op: 'glob', pattern: out};\n\t\n\t        return out;\n\t\n\t        function parseEnvVar() {\n\t            i += 1;\n\t            var varend, varname;\n\t            //debugger\n\t            if (s.charAt(i) === '{') {\n\t                i += 1;\n\t                if (s.charAt(i) === '}') {\n\t                    throw new Error(\"Bad substitution: \" + s.substr(i - 2, 3));\n\t                }\n\t                varend = s.indexOf('}', i);\n\t                if (varend < 0) {\n\t                    throw new Error(\"Bad substitution: \" + s.substr(i));\n\t                }\n\t                varname = s.substr(i, varend - i);\n\t                i = varend;\n\t            }\n\t            else if (/[*@#?$!_\\-]/.test(s.charAt(i))) {\n\t                varname = s.charAt(i);\n\t                i += 1;\n\t            }\n\t            else {\n\t                varend = s.substr(i).match(/[^\\w\\d_]/);\n\t                if (!varend) {\n\t                    varname = s.substr(i);\n\t                    i = s.length;\n\t                } else {\n\t                    varname = s.substr(i, varend.index);\n\t                    i += varend.index - 1;\n\t                }\n\t            }\n\t            return getVar(null, '', varname);\n\t        }\n\t    })\n\t    // finalize parsed aruments\n\t    .reduce(function(prev, arg){\n\t        if (arg === undefined){\n\t            return prev;\n\t        }\n\t        return prev.concat(arg);\n\t    },[]);\n\t\n\t    function getVar (_, pre, key) {\n\t        var r = typeof env === 'function' ? env(key) : env[key];\n\t        if (r === undefined) r = '';\n\t\n\t        if (typeof r === 'object') {\n\t            return pre + TOKEN + json.stringify(r) + TOKEN;\n\t        }\n\t        else return pre + r;\n\t    }\n\t}\n\n\n/***/ },\n\n/***/ 253:\n/***/ function(module, exports) {\n\n\tmodule.exports = extend\n\t\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\n\tfunction extend() {\n\t    var target = {}\n\t\n\t    for (var i = 0; i < arguments.length; i++) {\n\t        var source = arguments[i]\n\t\n\t        for (var key in source) {\n\t            if (hasOwnProperty.call(source, key)) {\n\t                target[key] = source[key]\n\t            }\n\t        }\n\t    }\n\t\n\t    return target\n\t}\n\n\n/***/ },\n\n/***/ 254:\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"child_process\");\n\n/***/ }\n\n/******/ })\n});\n;\n\n\n// WEBPACK FOOTER //\n// quark.bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap bd1464aab80b4bf2f3ee","import stream from './stream'\n\nlet previousTime\n\nconst coerce = (val) => val instanceof Error ? val.stack || val.message : val\nconst log = stream()\n\nmodule.exports = (namespace) => {\n  return (...args) => {\n    const currentTime = new Date()\n    const diff = currentTime - (previousTime || currentTime)\n    previousTime = currentTime\n\n    args = args.map(arg => coerce(arg))\n\n    log(JSON.stringify({\n      diff: diff,\n      time: currentTime,\n      tag: namespace,\n      data: args\n    }))\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib.js","module.exports = require(\"path\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"path\"\n// module id = 69\n// module chunks = 1 2","/**\n * Array#filter.\n *\n * @param {Array} arr\n * @param {Function} fn\n * @return {Array}\n */\n\nmodule.exports = function (arr, fn) {\n  if (arr.filter) return arr.filter(fn);\n  var ret = [];\n  for (var i = 0; i < arr.length; i++) {\n    if (!hasOwn.call(arr, i)) continue;\n    if (fn(arr[i], i, arr)) ret.push(arr[i]);\n  }\n  return ret;\n};\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/array-filter/index.js\n// module id = 113\n// module chunks = 1","module.exports = function (xs, f) {\n    if (xs.map) return xs.map(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = xs[i];\n        if (hasOwn.call(xs, i)) res.push(f(x, i, xs));\n    }\n    return res;\n};\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/array-map/index.js\n// module id = 114\n// module chunks = 1","var hasOwn = Object.prototype.hasOwnProperty;\n\nmodule.exports = function (xs, f, acc) {\n    var hasAcc = arguments.length >= 3;\n    if (hasAcc && xs.reduce) return xs.reduce(f, acc);\n    if (xs.reduce) return xs.reduce(f);\n    \n    for (var i = 0; i < xs.length; i++) {\n        if (!hasOwn.call(xs, i)) continue;\n        if (!hasAcc) {\n            acc = xs[i];\n            hasAcc = true;\n            continue;\n        }\n        acc = f(acc, xs[i], i);\n    }\n    return acc;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/array-reduce/index.js\n// module id = 115\n// module chunks = 1","import path from 'path'\nimport xtend from 'xtend'\nimport { spawn } from 'child_process'\nimport { parse } from 'shell-quote'\n\nconst PATH_SEP = process.platform === 'win32' ? ';' : ':'\nconst PATH_KEY = process.platform === 'win32' && !(process.env.PATH && !process.env.Path) ? 'Path' : 'PATH'\nconst ESCAPE_CHAR = process.platform === 'win32' ? '^' : '\\\\'\nconst ELECTRON_LIB = `electron ${path.join(__dirname, 'electron.bundle.js')}`\n\nconst commandToString = (cmd) => cmd.pattern || cmd.op || handleQuotes(cmd)\n\nconst handleQuotes = (s) => {\n  if (/[\"'\\s]/.test(s)) return '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"'\n  if (/[\"\\s]/.test(s) && !/'/.test(s)) return \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\"\n  return String(s).replace(/([\\\\$`()!#&*|])/g, '\\\\$1')\n}\n\nconst NPMBinPath = (cwd, PATH) => {\n  const result = []\n  let parent\n\n  while (true) {\n    parent = path.join(cwd, '..')\n    result.push(path.join(cwd, 'node_modules/.bin'))\n    if (parent === cwd) return result.concat(PATH).join(PATH_SEP)\n    cwd = parent\n  }\n}\n\nconst formatAndSpawn = (command, opts) => {\n  const options = xtend({}, opts)\n  let file\n  let args\n\n  if (process.platform === 'win32') {\n    file = process.env.comspec || 'cmd.exe'\n    args = [ '/s', '/c', '\"' + command + '\"' ]\n    options.windowsVerbatimArguments = true\n  } else {\n    file = '/bin/sh'\n    args = [ '-c', command ]\n    options.windowsVerbatimArguments = false\n  }\n\n  if (options && options.shell) {\n    file = options.shell\n    delete options.shell\n  }\n\n  return spawn(file, args, options)\n}\n\nmodule.exports = () => {\n  const cwd = process.cwd()\n  const env = process.env\n  const parsed = parse(ELECTRON_LIB, xtend({ '': '$' }), { escape: ESCAPE_CHAR }).map(commandToString).join(' ')\n\n  const override = {\n    [ PATH_KEY ]: NPMBinPath(path.resolve(cwd, '.'), env[PATH_KEY] || process.env[PATH_KEY])\n  }\n\n  const child = formatAndSpawn(parsed, { env: xtend(env, override) })\n  let out = child.stdin.write.bind(child.stdin)\n\n  child.stdin.setEncoding('utf-8')\n  child.stdout.pipe(process.stdout)\n\n  child.on('exit', () => {\n    out = console.log.bind(console)\n  })\n\n  return (log) => out(log)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/stream.js","exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jsonify/index.js\n// module id = 173\n// module chunks = 1","var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jsonify/lib/parse.js\n// module id = 174\n// module chunks = 1","var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jsonify/lib/stringify.js\n// module id = 175\n// module chunks = 1","var json = typeof JSON !== undefined ? JSON : require('jsonify');\nvar map = require('array-map');\nvar filter = require('array-filter');\nvar reduce = require('array-reduce');\n\nexports.quote = function (xs) {\n    return map(xs, function (s) {\n        if (s && typeof s === 'object') {\n            return s.op.replace(/(.)/g, '\\\\$1');\n        }\n        else if (/[\"\\s]/.test(s) && !/'/.test(s)) {\n            return \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n        }\n        else if (/[\"'\\s]/.test(s)) {\n            return '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n        }\n        else {\n            return String(s).replace(/([#!\"$&'()*,:;<=>?@\\[\\\\\\]^`{|}])/g, '\\\\$1'); \n        }\n    }).join(' ');\n};\n\nvar CONTROL = '(?:' + [\n    '\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '[&;()|<>]'\n].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\n\nvar TOKEN = '';\nfor (var i = 0; i < 4; i++) {\n    TOKEN += (Math.pow(16,8)*Math.random()).toString(16);\n}\n\nexports.parse = function (s, env, opts) {\n    var mapped = parse(s, env, opts);\n    if (typeof env !== 'function') return mapped;\n    return reduce(mapped, function (acc, s) {\n        if (typeof s === 'object') return acc.concat(s);\n        var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n        if (xs.length === 1) return acc.concat(xs[0]);\n        return acc.concat(map(filter(xs, Boolean), function (x) {\n            if (RegExp('^' + TOKEN).test(x)) {\n                return json.parse(x.split(TOKEN)[1]);\n            }\n            else return x;\n        }));\n    }, []);\n};\n\nfunction parse (s, env, opts) {\n    var chunker = new RegExp([\n        '(' + CONTROL + ')', // control chars\n        '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\n    ].join('|'), 'g');\n    var match = filter(s.match(chunker), Boolean);\n    var commented = false;\n\n    if (!match) return [];\n    if (!env) env = {};\n    if (!opts) opts = {};\n    return map(match, function (s, j) {\n        if (commented) {\n            return;\n        }\n        if (RegExp('^' + CONTROL + '$').test(s)) {\n            return { op: s };\n        }\n\n        // Hand-written scanner/parser for Bash quoting rules:\n        //\n        //  1. inside single quotes, all characters are printed literally.\n        //  2. inside double quotes, all characters are printed literally\n        //     except variables prefixed by '$' and backslashes followed by\n        //     either a double quote or another backslash.\n        //  3. outside of any quotes, backslashes are treated as escape\n        //     characters and not printed (unless they are themselves escaped)\n        //  4. quote context can switch mid-token if there is no whitespace\n        //     between the two quote contexts (e.g. all'one'\"token\" parses as\n        //     \"allonetoken\")\n        var SQ = \"'\";\n        var DQ = '\"';\n        var DS = '$';\n        var BS = opts.escape || '\\\\';\n        var quote = false;\n        var esc = false;\n        var out = '';\n        var isGlob = false;\n\n        for (var i = 0, len = s.length; i < len; i++) {\n            var c = s.charAt(i);\n            isGlob = isGlob || (!quote && (c === '*' || c === '?'));\n            if (esc) {\n                out += c;\n                esc = false;\n            }\n            else if (quote) {\n                if (c === quote) {\n                    quote = false;\n                }\n                else if (quote == SQ) {\n                    out += c;\n                }\n                else { // Double quote\n                    if (c === BS) {\n                        i += 1;\n                        c = s.charAt(i);\n                        if (c === DQ || c === BS || c === DS) {\n                            out += c;\n                        } else {\n                            out += BS + c;\n                        }\n                    }\n                    else if (c === DS) {\n                        out += parseEnvVar();\n                    }\n                    else {\n                        out += c;\n                    }\n                }\n            }\n            else if (c === DQ || c === SQ) {\n                quote = c;\n            }\n            else if (RegExp('^' + CONTROL + '$').test(c)) {\n                return { op: s };\n            }\n            else if (RegExp('^#$').test(c)) {\n                commented = true;\n                if (out.length){\n                    return [out, { comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n                }\n                return [{ comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n            }\n            else if (c === BS) {\n                esc = true;\n            }\n            else if (c === DS) {\n                out += parseEnvVar();\n            }\n            else out += c;\n        }\n\n        if (isGlob) return {op: 'glob', pattern: out};\n\n        return out;\n\n        function parseEnvVar() {\n            i += 1;\n            var varend, varname;\n            //debugger\n            if (s.charAt(i) === '{') {\n                i += 1;\n                if (s.charAt(i) === '}') {\n                    throw new Error(\"Bad substitution: \" + s.substr(i - 2, 3));\n                }\n                varend = s.indexOf('}', i);\n                if (varend < 0) {\n                    throw new Error(\"Bad substitution: \" + s.substr(i));\n                }\n                varname = s.substr(i, varend - i);\n                i = varend;\n            }\n            else if (/[*@#?$!_\\-]/.test(s.charAt(i))) {\n                varname = s.charAt(i);\n                i += 1;\n            }\n            else {\n                varend = s.substr(i).match(/[^\\w\\d_]/);\n                if (!varend) {\n                    varname = s.substr(i);\n                    i = s.length;\n                } else {\n                    varname = s.substr(i, varend.index);\n                    i += varend.index - 1;\n                }\n            }\n            return getVar(null, '', varname);\n        }\n    })\n    // finalize parsed aruments\n    .reduce(function(prev, arg){\n        if (arg === undefined){\n            return prev;\n        }\n        return prev.concat(arg);\n    },[]);\n\n    function getVar (_, pre, key) {\n        var r = typeof env === 'function' ? env(key) : env[key];\n        if (r === undefined) r = '';\n\n        if (typeof r === 'object') {\n            return pre + TOKEN + json.stringify(r) + TOKEN;\n        }\n        else return pre + r;\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/shell-quote/index.js\n// module id = 246\n// module chunks = 1","module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xtend/immutable.js\n// module id = 253\n// module chunks = 1","module.exports = require(\"child_process\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"child_process\"\n// module id = 254\n// module chunks = 1"],"sourceRoot":""}